<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/css/bootstrap.min.css" rel="stylesheet">

    <title>Brick Breaker</title>

    <style>
        canvas {
            padding: 0;
            margin: auto;
            display: block;
            width: 800px;
            height: 800px;
        }

        .btn-group {
            width: 100%;
        }
    </style>
</head>
<body class="bg-dark">
<script src=final.js></script>
<script src=math.js></script>
<script src=matrix.js></script>
<script src=geometry.js></script>
<script src=game.js></script>

<nav class="navbar navbar-expand-lg navbar-dark bg-dark" style="margin-bottom: 20px;">
    <div class="container-fluid">
        <span class="navbar-brand mb-0 h1">Brick Breaker</span>
    </div>
</nav>

<div class="container">
    <div class="row">
        <div class="col-3 p-5 text-white bg-dark rounded-3 border">
            <div class="btn-group" role="group">
                <button type="button" class="btn btn-primary" id="start-pause-btn">Start</button>
                <button type="button" class="btn btn-info" id="new-game-btn">New Game</button>
            </div>
            <hr>
            <form>
                <div class="mb-3">
                    <label for="gameSpeed" class="form-label">Game Speed: <span id="game-speed-value">0.4</span></label>
                    <input type="range" class="form-range" min="0.1" max="1" value="0.4" step="0.1" id="gameSpeed">
                </div>
            </form>
        </div>
        <div class="col-9">
            <canvas id='canvas1' width="800" height="800" class="bg-dark rounded-3 border"></canvas>
        </div>
    </div>
</div>


<!--<span style="font-size: large; ">
    The first button shuffles the list. The second button starts or pauses the animation.
</span>-->

<div id="errorMessage" style="display: none"></div>
<div id=errorMarker style="display: none"></div>

<!!-------- VERTEX SHADER -------->

<script id='my_vertex_shader' type='x-shader/x-vertex'>
    uniform   float uTime;
    uniform   mat4  uMatrix, uInvMatrix, uCamera;
    attribute vec3  aPos;
    attribute vec3  aNor;
    varying   vec3  vPos;
    varying   vec3  vNor;
    void main() {

        // CAMERA MATRIX IS APPLIED AFTER ALL OTHER TRANSFORMATIONS.
        // THAT IS WHY IT MULTIPLIES FROM THE LEFT.

        vec4 pos = uCamera * uMatrix * vec4(aPos, 1.);

        // NORMAL IS RIGHT-MULTIPLIED BY INVERSE OF MATRIX.

        vec4 nor = vec4(aNor, 0.) * uInvMatrix;
        gl_Position = pos;
        vPos = pos.xyz;
        vNor = nor.xyz;
    }
</script>


<!!-------- FRAGMENT SHADER -------->

<script id='my_fragment_shader' type='x-shader/x-fragment'>

    uniform float uTime;   // TIME, IN SECONDS

    varying vec3 vPos;
    varying vec3 vNor;

    float fl = 3.0;

    const int nl = 2; // NUMBER OF LIGHTS
    const int ns = 2; // NUMBER OF SPHERES

    uniform vec3 uLDir[nl];
    uniform vec3 uLCol[nl];

    uniform vec3 uAmbient;
    uniform vec3 uDiffuse;
    uniform vec4 uSpecular;

    void main() {
        vec3 N = normalize(vNor);

        // WE DO PHONG SHADING HERE ONLY FOR MATERIAL 0.

        vec3 color = uAmbient;
        for (int n = 0 ; n < nl ; n++) {
            vec3 R = 2. * dot(uLDir[n], N) * N - uLDir[n];
            color += uLCol[n] * (uDiffuse * max(0., dot(uLDir[n], N)) + uSpecular.rgb * pow(max(0., R.z), uSpecular.w));
        }
        gl_FragColor = vec4(sqrt(color), 1.0);
    }
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/js/bootstrap.bundle.min.js"></script>

<!!-------- GENERAL SUPPORT CODE -------->
<script>

    // CREATE THE HTML DOCUMENT

    let vs = my_vertex_shader.innerHTML,
        fs = my_fragment_shader.innerHTML;
    fs = fs.substring(1, fs.length);

    //----------- REPARSE THE SHADER PROGRAM AFTER EVERY KEYSTROKE.

    let startTime = Date.now();

    let r3 = Math.sqrt(1/3);

    let hermiteMatrix = [ 2,-3,0,1, -2,3,0,0, 1,-2,1,0, 1,-1,0,0 ];

    //----------- DEFINE MATERIALS

    materials['black'  ] = { ambient: [.0,.0,.0], diffuse: [0,0,0], specular: [.9,.9,.9,10] };
    materials['blue'   ] = { ambient: [.0,.0,.2], diffuse: [0,0,1], specular: [.9,.9,.9,10] };
    materials['brass'  ] = { ambient: [.03,.02,.01], diffuse: [.03,.02,.01], specular: [.9,.6,.3,10] };
    materials['cyan'   ] = { ambient: [.0,.15,.15], diffuse: [0,.075,.075], specular: [0,.7,.7,10] };
    materials['gold'   ] = { ambient: [.2,.15,0], diffuse: [.1,.075,0], specular: [1,.7,.0,10] };
    materials['green'  ] = { ambient: [.0,.1,.0], diffuse: [0,.5,0], specular: [.6,.6,.6,10] };
    materials['magenta'] = { ambient: [.1,.0,.1], diffuse: [.5,0,.5], specular: [.6,.0,.6,10] };
    materials['red'    ] = { ambient: [.2,.0,.0], diffuse: [1,0,0], specular: [.9,.9,.9,10] };
    materials['steel'  ] = { ambient: [.03,.03,.03], diffuse: [.03,.03,.03], specular: [1,1,1,15] };
    materials['white'  ] = { ambient: [.2,.2,.2], diffuse: [1,1,1], specular: [.9,.9,.9,10] };
    materials['yellow' ] = { ambient: [.2,.2,.0], diffuse: [1,1,0], specular: [.9,.9,.0,10] };

    //----------- DEFINE THE HERMITE SPLINE CURVE DATA

    let hx = [ -.5,  0.0,     0,  0.8,    .5,  0.0,    0, -0.8,   -.5,  0.0 ];
    let hy = [   0, -0.8,   -.5,  0.0,     0,  0.8,   .5,  0.0,     0, -0.8 ];
    let hz = [   0,  0.0,     0,  0.0,     0,  0.0,    0,  0.0,     0,  0.0 ];

    //----------- FOCAL LENGTH OF CAMERA

    let fl = 3;

    //----------- FIND OUT WHETHER A RAY HITS A SPHERE

    let rayHitsSphere = (V, W, S) => {
        let Vp = [ V[0] - S[0], V[1] - S[1], V[2] - S[2] ];
        let vw = dot(Vp, W);
        let d = vw * vw - dot(Vp, Vp) + S[3] * S[3];
        return d > 0;
    }

    //----------- ANIMATE EACH FRAME

    function animate(gl) {
        let time = (Date.now() - startTime) / 1000;

        next_frame();
        hit_detection();

        // SET ANIMATION TIME IN FRAGMENT SHADER

        setUniform('1f', 'uTime', time);

        // SET LIGHT POSITION AND COLOR FOR RAYTRACING

        setUniform('3fv', 'uLDir', [r3,r3,r3, -r3,-r3,-r3]);
        setUniform('3fv', 'uLCol', [.6,.8,1, .4,.3,.2]);

        // SET SURFACE REFLECTANCE PROPERTIES

        setUniform('3fv', 'uAmbient' , [.2,.2,.2]);
        setUniform('3fv', 'uDiffuse' , [1,1,1]);
        setUniform('4fv', 'uSpecular', [.9,.9,.9,10]);

        setUniform('Matrix4fv', 'uCamera', false, matrix_perspective(3));

        draw();
    }

    let ball;
    let paddle;
    let bricks;

    let running = false;

    const next_frame = () => {
        if (!running)
            return;

        ball.next_frame();
        paddle.next_frame();
    }

    const hit_detection = () => {
        if (!running)
            return;

        ball.hit_detection(paddle);

        for (const brick of bricks) {
            if (brick.destroyed)
                continue;

            ball.hit_detection(brick);
        }
    }

    const draw = () => {
        ball.draw();
        paddle.draw();

        for (const brick of bricks)
            brick.draw();
    }

    const new_game = () => {
        pause_game();

        ball = new Ball();
        paddle = new Paddle();
        bricks = [];

        running = false;

        for (let y = - Brick.scaleYZ / 5; y < Brick.scaleYZ - 1; y += 4)
            for (let x = - Brick.scaleX + 3; x <= Brick.scaleX - 3; x += 3) {
                bricks.push(new Brick(x, y));
            }
    }

    const start_game = () => {
        running = true;
        $("#start-pause-btn").html("Pause");
        $("#start-pause-btn").removeClass('btn-primary');
        $("#start-pause-btn").addClass('btn-warning');
    }

    const pause_game = () => {
        running = false;
        $("#start-pause-btn").html("Start");
        $("#start-pause-btn").removeClass('btn-warning');
        $("#start-pause-btn").addClass('btn-primary');
    }

    const change_speed = () => {
        const speed = parseFloat($("#gameSpeed").val());
        ball.speed = speed;
        $("#game-speed-value").html(speed);
    }

    $("#start-pause-btn").click(() => {
        if (running)
            pause_game();
        else
            start_game();
    });

    $("#new-game-btn").click(new_game);
    $("#gameSpeed").on('input change', change_speed);

    new_game();

    // RECORD WHETHER ANY KEY IS PRESSED

    canvas1.onKeyPress   = k => {
        if (k === 37)
            paddle.move_left();

        else if (k === 39)
            paddle.move_right();

        else
            paddle.stop();
    }

    canvas1.onKeyRelease = k => paddle.stop();

    // START EVERYTHING

    gl_start(canvas1, vs, fs);
</script>
</body>
</html>




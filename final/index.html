<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/css/bootstrap.min.css" rel="stylesheet">

    <title>Hello, world!</title>

    <style>
        canvas {
            padding: 0;
            margin: auto;
            display: block;
            width: 800px;
            height: 800px;
            border:3px solid #f8f9fa;
        }
    </style>
</head>
<body class="bg-dark">
<script src=final.js></script>
<script src=math.js></script>
<script src=matrix.js></script>
<script src=geometry.js></script>

<nav class="navbar navbar-expand-lg navbar-dark bg-dark" style="margin-bottom: 20px;">
    <div class="container-fluid">
        <span class="navbar-brand mb-0 h1">Brick Breaker</span>
    </div>
</nav>

<canvas id='canvas1' width="800" height="800"></canvas>

<!--<span style="font-size: large; ">
    The first button shuffles the list. The second button starts or pauses the animation.
</span>-->

<div id="errorMessage" style="display: none"></div>
<div id=errorMarker style="display: none"></div>

<!!-------- VERTEX SHADER -------->

<script id='my_vertex_shader' type='x-shader/x-vertex'>
    uniform   float uTime;
    uniform   mat4  uMatrix, uInvMatrix, uCamera;
    attribute vec3  aPos;
    attribute vec3  aNor;
    varying   vec3  vPos;
    varying   vec3  vNor;
    void main() {

        // CAMERA MATRIX IS APPLIED AFTER ALL OTHER TRANSFORMATIONS.
        // THAT IS WHY IT MULTIPLIES FROM THE LEFT.

        vec4 pos = uCamera * uMatrix * vec4(aPos, 1.);

        // NORMAL IS RIGHT-MULTIPLIED BY INVERSE OF MATRIX.

        vec4 nor = vec4(aNor, 0.) * uInvMatrix;
        gl_Position = pos;
        vPos = pos.xyz;
        vNor = nor.xyz;
    }
</script>


<!!-------- FRAGMENT SHADER -------->

<script id='my_fragment_shader' type='x-shader/x-fragment'>

    uniform float uTime;   // TIME, IN SECONDS

    varying vec3 vPos;
    varying vec3 vNor;

    float fl = 3.0;

    const int nl = 2; // NUMBER OF LIGHTS
    const int ns = 2; // NUMBER OF SPHERES

    uniform vec3 uLDir[nl];
    uniform vec3 uLCol[nl];

    uniform vec3 uAmbient;
    uniform vec3 uDiffuse;
    uniform vec4 uSpecular;

    void main() {
        vec3 N = normalize(vNor);

        // WE DO PHONG SHADING HERE ONLY FOR MATERIAL 0.

        vec3 color = uAmbient;
        for (int n = 0 ; n < nl ; n++) {
            vec3 R = 2. * dot(uLDir[n], N) * N - uLDir[n];
            color += uLCol[n] * (uDiffuse * max(0., dot(uLDir[n], N)) + uSpecular.rgb * pow(max(0., R.z), uSpecular.w));
        }
        gl_FragColor = vec4(sqrt(color), 1.0);
    }
</script>

<!!-------- GENERAL SUPPORT CODE -------->
<script>

    // CREATE THE HTML DOCUMENT

    let vs = my_vertex_shader.innerHTML,
        fs = my_fragment_shader.innerHTML;
    fs = fs.substring(1, fs.length);

    //----------- REPARSE THE SHADER PROGRAM AFTER EVERY KEYSTROKE.

    let startTime = Date.now();

    let r3 = Math.sqrt(1/3);

    let hermiteMatrix = [ 2,-3,0,1, -2,3,0,0, 1,-2,1,0, 1,-1,0,0 ];

    //----------- DEFINE MATERIALS

    materials['black'  ] = { ambient: [.0,.0,.0], diffuse: [0,0,0], specular: [.9,.9,.9,10] };
    materials['blue'   ] = { ambient: [.0,.0,.2], diffuse: [0,0,1], specular: [.9,.9,.9,10] };
    materials['brass'  ] = { ambient: [.03,.02,.01], diffuse: [.03,.02,.01], specular: [.9,.6,.3,10] };
    materials['cyan'   ] = { ambient: [.0,.15,.15], diffuse: [0,.075,.075], specular: [0,.7,.7,10] };
    materials['gold'   ] = { ambient: [.2,.15,0], diffuse: [.1,.075,0], specular: [1,.7,.0,10] };
    materials['green'  ] = { ambient: [.0,.1,.0], diffuse: [0,.5,0], specular: [.6,.6,.6,10] };
    materials['magenta'] = { ambient: [.1,.0,.1], diffuse: [.5,0,.5], specular: [.6,.0,.6,10] };
    materials['red'    ] = { ambient: [.2,.0,.0], diffuse: [1,0,0], specular: [.9,.9,.9,10] };
    materials['steel'  ] = { ambient: [.03,.03,.03], diffuse: [.03,.03,.03], specular: [1,1,1,15] };
    materials['white'  ] = { ambient: [.2,.2,.2], diffuse: [1,1,1], specular: [.9,.9,.9,10] };
    materials['yellow' ] = { ambient: [.2,.2,.0], diffuse: [1,1,0], specular: [.9,.9,.0,10] };

    //----------- DEFINE THE HERMITE SPLINE CURVE DATA

    let hx = [ -.5,  0.0,     0,  0.8,    .5,  0.0,    0, -0.8,   -.5,  0.0 ];
    let hy = [   0, -0.8,   -.5,  0.0,     0,  0.8,   .5,  0.0,     0, -0.8 ];
    let hz = [   0,  0.0,     0,  0.0,     0,  0.0,    0,  0.0,     0,  0.0 ];

    //----------- FOCAL LENGTH OF CAMERA

    let fl = 3;

    //----------- FIND OUT WHETHER A RAY HITS A SPHERE

    let rayHitsSphere = (V, W, S) => {
        let Vp = [ V[0] - S[0], V[1] - S[1], V[2] - S[2] ];
        let vw = dot(Vp, W);
        let d = vw * vw - dot(Vp, Vp) + S[3] * S[3];
        return d > 0;
    }

    //----------- ANIMATE EACH FRAME

    function animate(gl) {
        let time = (Date.now() - startTime) / 1000;

        ball.next_frame();
        paddle.next_frame();

        ball.hit_detection(paddle);

        for (const brick of bricks) {
            if (brick.destroyed)
                continue;

            ball.hit_detection(brick);
        }

        // SET ANIMATION TIME IN FRAGMENT SHADER

        setUniform('1f', 'uTime', time);

        // SET LIGHT POSITION AND COLOR FOR RAYTRACING

        setUniform('3fv', 'uLDir', [r3,r3,r3, -r3,-r3,-r3]);
        setUniform('3fv', 'uLCol', [.6,.8,1, .4,.3,.2]);

        // SET SURFACE REFLECTANCE PROPERTIES

        setUniform('3fv', 'uAmbient' , [.2,.2,.2]);
        setUniform('3fv', 'uDiffuse' , [1,1,1]);
        setUniform('4fv', 'uSpecular', [.9,.9,.9,10]);

        setUniform('Matrix4fv', 'uCamera', false, matrix_perspective(3));

        ball.draw();
        paddle.draw();

        for (const brick of bricks)
            brick.draw();
    }

    class Ball {
        static scale = 30

        x = 0;
        y = -5;

        speedX = 0.4;
        speedY = 0.4;

        hit_detection(other) {
            if (other instanceof Paddle) {
                // Horizontal
                if (
                    this.x / Ball.scale > (other.x - 1) / Paddle.scaleX
                    && this.x / Ball.scale < (other.x + 1) / Paddle.scaleX
                    && Math.abs(this.y / Ball.scale - other.y / Paddle.scaleYZ) < (1 / Ball.scale + 1 / Paddle.scaleYZ)
                ) {
                    this.speedY = -this.speedY
                }
                // Vertical
                // else if (
                //     this.y / this.scale > (other.y - 1) / other.scaleYZ
                //     && this.y / this.scale < (other.y + 1) / other.scaleYZ
                //     && Math.abs(this.x / this.scale - other.x / other.scaleX) < (1 / this.scale + 1 / other.scaleX)
                // ) {
                //     this.speedX = -this.speedX;
                // }
            }

            if (other instanceof Brick) {
                // Horizontal
                if (
                    this.x / Ball.scale > (other.x - 1) / Brick.scaleX
                    && this.x / Ball.scale < (other.x + 1) / Brick.scaleX
                    && Math.abs(this.y / Ball.scale - other.y / Brick.scaleYZ) < (1 / Ball.scale + 1 / Brick.scaleYZ)
                ) {
                    other.destroyed = true;
                    this.speedY = -this.speedY
                }
                // Vertical
                else if (
                    this.y / Ball.scale > (other.y - 1) / Brick.scaleYZ
                    && this.y / Ball.scale < (other.y + 1) / Brick.scaleYZ
                    && Math.abs(this.x / Ball.scale - other.x / Brick.scaleX) < (1 / Ball.scale + 1 / Brick.scaleX)
                ) {
                    other.destroyed = true;
                    this.speedX = -this.speedX;
                }
            }
        }

        next_frame() {
            this.x += this.speedX;
            this.y += this.speedY;

            if (Math.abs(this.x) > Ball.scale - 1)
                this.speedX = -this.speedX;

            if (Math.abs(this.y) > Ball.scale - 1)
                this.speedY = -this.speedY
        }

        draw() {
            M.save()
            M.scale(1 / Ball.scale)
            M.translate(this.x, this.y, 0)
            drawMesh(sphereMesh, 'white')
            M.restore();
        }
    }

    class Paddle {
        static scaleX = 10;
        static scaleYZ = 50;

        x = 0;
        y = -45;

        speedX = 0;

        move_left() {
            this.speedX = -0.5;
        }

        move_right() {
            this.speedX = 0.5;
        }

        stop() {
            this.speedX = 0;
        }

        next_frame() {
            this.x += this.speedX;

            if (this.x < - (Paddle.scaleX - 1))
                this.x = - (Paddle.scaleX - 1);

            if (this.x > Paddle.scaleX - 1)
                this.x = Paddle.scaleX - 1;
        }

        draw() {
            M.save()
            M.scale(1 / Paddle.scaleX, 1 / Paddle.scaleYZ, 1 / Paddle.scaleYZ)
            M.translate(this.x, this.y, 0)
            drawMesh(squareMesh, 'red')
            M.restore();
        }
    }

    class Brick {
        static scaleX = 15;
        static scaleYZ = 40;

        destroyed = false;

        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        draw() {
            if (this.destroyed)
                return;

            M.save();
            M.scale(1 / Brick.scaleX, 1 / Brick.scaleYZ, 1 / Brick.scaleYZ)
            M.translate(this.x, this.y, 0)
            drawMesh(squareMesh, 'green')
            M.restore();
        }
    }

    const ball = new Ball();
    const paddle = new Paddle();
    const bricks = [];

    for (let y = - Brick.scaleYZ / 5; y < Brick.scaleYZ - 1; y += 4)
        for (let x = - Brick.scaleX + 3; x <= Brick.scaleX - 3; x += 3) {
            bricks.push(new Brick(x, y));
        }



    // Brick.

    // RECORD WHETHER ANY KEY IS PRESSED

    canvas1.onKeyPress   = k => {
        if (k === 37)
            paddle.move_left();

        else if (k === 39)
            paddle.move_right();

        else
            paddle.stop();
    }

    canvas1.onKeyRelease = k => paddle.stop();

    // START EVERYTHING

    gl_start(canvas1, vs, fs);
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>



